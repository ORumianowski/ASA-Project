---
title: "Asa projet"
output: html_document
date: "2023-10-05"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

0. CHargement des packages necessaires et des donnees
```{r, echo=FALSE}
library(readxl)
library(vegan)
library(dplyr)
library("ggplot2")
library(corrplot)
library(PerformanceAnalytics) 

filePathLouis = "data_vegetation_french.xls"
# filePath = "C:/associationrs/33763/Desktop/MODE/ASA - Advanced statictics/Projet/data_vegetation_french.xls"
dataFlower <- read_xls(filePathLouis, sheet = "flo")

dataEnvironment <- read_xls(filePathLouis, sheet = "mil") %>%
  lapply(as.numeric) %>%
  as.data.frame()

colnames(dataEnvironment) <- c("Argile","Limon","Sable","K2O","Mg", "Na_100g","K", "Conduc","Capa_Reten","Na_Liter","Altitude"  )

dataCoord <- read_xls(filePathLouis, col_types = "numeric", sheet = "coord")

dasso <- read_xls(filePathLouis, sheet = "association")

head(dataFlower)
head(dataCoord)
head(dataEnvironment)
head(dasso)
```

## I. EXPLORATION DES DONNES
# 1. Exploration des donnees florales

```{r, echo=FALSE}
## DATA DESCRIPTION AND OBJECTIVES

# releve fleuristique

str(dataFlower)
summary(dataFlower)
```

On verifie qu'il n'y a pas de donnees manquantes
```{r}
colSums(is.na(dataFlower))
rowSums(is.na(dataFlower))
```
On verifie aussi que toutes les stations contiennent des fleurs
```{r}
rowSums(dataFlower)
```

```{r}
dataFlower2 = dataFlower!=0 #nombre de présence 

par(mfrow=c(2,2))
hist(colSums(dataFlower),col='blue')
hist(rowSums(dataFlower),col='blue')
hist(colSums(dataFlower2),col='blue')
hist(rowSums(dataFlower2),col='blue')
```

# 2. Exploration des donnees environnementales
```{r, echo=FALSE}
str(dataEnvironment)
summary(dataEnvironment)
colSums(is.na(dataEnvironment))
rowSums(is.na(dataEnvironment))
# There is no missing value.
```
verification de la distribution, absence d'outliers, normalite
```{r}
par(mfrow=c(2,3), mar = c(3, 3, 1, 1), cex.lab = 0.7, mgp = c(1.5, 0.5, 0))
xlabel <- colnames(dataEnvironment)
for(i in 1:ncol(dataEnvironment)){
  dotchart(dataEnvironment[,i], xlab=xlabel[i], pch=20, col="blue", main=paste("Cleveland plot",xlabel[i]))
  hist(dataEnvironment[,i], xlab=xlabel[i], pch=20, col="blue",main=paste("Distribution",xlabel[i]))
  qqnorm(dataEnvironment[,i], xlab=xlabel[i], pch=20, col="blue")
  qqline(dataEnvironment[,i], col="red")
}
```

# 3. Verification de la colinearite entre Xi
```{r, echo=FALSE}
par(mfrow=c(1,1))
M <- cor(dataEnvironment)
corrplot.mixed(M,upper="square",lower.col="black", tl.col="black",cl.cex = 0.7,tl.cex = 0.6,number.cex =0.7)


chart.Correlation(dataEnvironment,histogram=TRUE, pch=19)#associationfull if few variables

```

```{r, echo=FALSE}
dataEnvironment_selected = subset(dataEnvironment, select = -c(Argile, Na_100g, Na_Liter))
chart.Correlation(dataEnvironment_selected,histogram=TRUE, pch=19)#associationfull if few variables

```

Repartition des donnes dans l'espace
```{r, echo=FALSE}
str(dataCoord)
plot(dataCoord)
```

## II. RECHERCHE D'UNE AUTOCORRELATION SPATIALE

# Test de Mantel pour l'autocorrélation spatiale 

Dans cette partie, nous allons effectuer un test de Mantel pour évaluer la corrélation entre deux matrices de distance : la matrice spatiale et la matrice des caractéristiques du milieu.

Le test de Mantel est utilisé pour détecter une éventuelle autocorrélation spatiale dans les données multivariées, en considérant à la fois la distance géographique et la distance entre les caractéristiques du milieu.

## Matrice géographique

Pour commencer, nous importons les données spatiales à partir du fichier `coord` et calculons la matrice de distance géographique en utilisant la distance euclidienne.

```{r}
# Calcul de la matrice de distance spatiale
spatial <- dist(dataCoord) # Matrice spatiale

```

## Matrice du milieu
Ensuite, nous importons les données sur l'environnement à partir du fichier `mil.txt` et préparons la matrice de distance en supprimant les colonnes corrélés (Argile, Na100g et Na+). Nous standardisons également les données en les divisant par l'écart-type.
```{r}
# Calcul de la matrice de distance du milieu (standardisée)
matriceMilieu <- dist(scale(dataEnvironment_selected), method = "euclidean") # Matrice du milieu

```

## Test de Mantel
Nous effectuons maintenant le test de Mantel pour évaluer la corrélation entre les deux matrices.
```{r}
# Test de Mantel
library(ade4)
R <- mantel.randtest(spatial, matriceMilieu, nrepet = 1000)

# Affichage des résultats
R # p-value: 0.03896104, Observation: 0.07646109 
plot(R, main = "Test de Mantel")

```

Les résultats du test de Mantel montrent une corrélation positive faible entre les deux matrices de distance.

## Conclusion

En conclusion, il existe une similitude entre les variables caractérisant le site de l'étude, expliquée par leur proximité géographique.


## III. DETERMINATION DES VARIABLES STRUCTURANT LES COMMUNAUTES AVEC UNE PCCA

# 1. Standardisation 

Certaines espèces sont très fréquentes sur certains sites (lorsque les conditions sont favorables), ou absentes de nombreux sites. Cette asymétrie peut introduire des problèmes parasites dans nos analyses. Ainsi nous allons transformer nos données de composition pour les analyser de manière appropriée.
La transformation de Hellinger permet de réduire les effets des valeurs extrêmement grandes.

On ramene aussi les donnes environnementales sur la meme echelle, car elles ont chacune des unites de mesures et des valeurs tres differentes. Il s'agit donc de les centrer-reduire afin de rendre plus comparable leur effet. Cela permet aussi d'etre plus proche de l'hypothese de normalite multivariee (une des hypothese en analyse canonique), et donc d'obtenir des resultat plus fiable.
```{r}
dataFlower_standardized <- decostand(dataFlower, "hellinger")
dataEnvironment_selected = scale(dataEnvironment_selected)
```

# 2. Selection des variables pertinententes avec ordistep

ordistep permet de selectionner les variables a conserver dans le modele en se basant sur des tests de permutations. Les variables qui ne permettent pas une amelioration significative du modele sont ainsi retires.

Dans le code ci-dessous, on construit tout d'abord la formule que le modele devra utiliser afin de specifier que les donnees spatiales doivent etre pris en compte dans le modele afin de retirer la part de variance explique par les variables environnementales qui serait liee a de l'autocorrelation spatiale.
```{r}
dataEnvironmentAndCoord = cbind(dataEnvironment_selected, dataCoord)

formule_pcca <- formula(paste("dataFlower ~",                              paste(names(dataEnvironmentAndCoord)[1:(length(dataEnvironmentAndCoord)-(length(dataCoord)))], collapse = " + "), "+ Condition (", paste(names(dataEnvironmentAndCoord)[(length(dataEnvironmentAndCoord)-(length(dataCoord)-1)):length(dataEnvironmentAndCoord)], collapse ="+"),")"))

print(formule_pcca)

pccaModel <- cca(formule_pcca, dataEnvironmentAndCoordy,scan=F)

ordistep(pccaModel,perm.max=500)
```

# 3. Construction du modele finale

Finalement, apres selection de variable il nous reste 6 variables environnementales : Sable, Mg, K, Conduc, Capa_Reten et Altitude. Le modele finale est donc le suivant :
```{r}
formulePcca_finale = formula("dataFlower ~ Sable + Mg + K + Conduc + Capa_Reten + Altitude +
Condition(x + y)")
pccaModel_finale <- cca(formulePcca_finale, dataEnvironmentAndCoordy,scan=F)
```

# 4. Validite et significativite du modele

Tout d'abord verifions que les variables retenues n'ont pas une correlation trop forte entre elles (ce qui doit etre le cas etant donne que cela a ete verifie lors de l'exploration des donnees)
```{r}
vif.cca(pccaModel_finale) 
```
Toutes les valuers de VIF < 10 => ok

Regardons la part de variance expliquee par notre modele
```{r}
pccaModel_finale
```

On verifie que la pCCA est bien significative
```{r}
anova.cca(pccaModel_finale)
```

Finalement, les resultats de la pCCA sont significatifs (p=0,001). L'inertie totale de l'analyse est 8.33, l'environnement en explique 11,6% et les donnees spatiales 8,8%

Les 2 premiers axes representent 56,6% de la variance expliquee par l'environnement (independament de l'effet spatiale), et 6,6% de la variance totale.



partitionnement de variance :
```{r}
m = varpart(dataFlower,dataEnvironment,dataCoord)
m
plot(m, bg=2:5)
```

5. Importance des variables dans le modele
On peut aussi verifier la significativité de chaque variable environnementale du modele
```{r}
anova(pccaModel_finale, by="terms", perms.max=1000)
```

```{r}
pccaModel_finale$CCA$biplot
```

6. Representation des resultats
```{r}
plot(pccaModel_finale,scaling=1) 
plot(pccaModel_finale,scaling=2) 

plot(pccaModel_finale, type="n", scaling =3)
text(pccaModel_finale, dis="cn",col="black",cex = 1.2)
text(pccaModel_finale, "species", col="blue", cex=0.8)
```

Ici la representation est refaite en colorant selon la communauté vegetale de chaque site (determine par un expert)
```{r}
scl <- 2 
colvec <- c("darkred", "darkblue", "darkgreen","darkorange","darkmagenta","darkcyan","darkgrey")

association = unique(dasso$association) %>%
  as.factor()
dataEnvironmentAndCoord$association <- as.factor(dasso$association)
#head(with(dataEnvironmentAndCoord, colvec[association]))

# Ajouter les axes sans les points :
plot(pccaModel_finale, type = "n", scaling = scl)
# Ajouter les fleches pour les variables environnementales :
text(pccaModel_finale, dis="cn",col="black",cex = 1.2)
# Ajouter les points (1 point = 1 ligne = 1 site)
with(dataEnvironmentAndCoord, points(pccaModel_finale, display = "sites", col = colvec[association],
                      scaling = scl, pch = 21, bg = colvec[association]))
# Ajout des especes : (ça fait charge)
#text(pccaModel_finale, display = "species", scaling = scl, cex = 0.8, col = "darkcyan")
# Ajout d'une legende pour les couleurs :
with(dataEnvironmentAndCoord, legend("topright", legend = levels(association), bty = "n",
                      col = colvec, pch = 21, pt.bg = colvec))
```

